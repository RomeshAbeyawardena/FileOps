----FileOps/ApplicationConfiguration.cs----
using Shared;

namespace FileOps;

internal class ApplicationConfiguration
{
    [ArgumentDescriptor(ArgumentName = "file-name")]
    public string? FileName { get; set; }
    [ArgumentDescriptor(ArgumentName = "json-value")]
    public string? Json { get; set; }
}

----END OF FILE----
----FileOps/Program.cs----
using FileOps;
using FileOps.Core;
using FileOps.Core.Features.Parse;
using FileOps.Core.Features.Process;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using Shared.Console;
using Shared.Console.Extensions;

using var cancellationTokenRegistration = new CancellationTokenRegistration();
var cancellationToken = cancellationTokenRegistration.Token;

ApplicationConfiguration applicationConfiguration = new();
applicationConfiguration.Parse(ArgumentParser.GetParameters(args, false));

var serviceConfiguration = new ServiceCollection().RegisterServices(new[] {
    typeof(Program).Assembly
});

var services = serviceConfiguration.BuildServiceProvider();
var mediator = services.GetRequiredService<IMediator>();

bool hasFileName = !string.IsNullOrWhiteSpace(applicationConfiguration.FileName);
if (!hasFileName) 
{
    throw new NullReferenceException($"File '{applicationConfiguration.FileName}' not found");
}

if(!hasFileName && string.IsNullOrWhiteSpace(applicationConfiguration.Json))
{
    throw new NullReferenceException("Must specify either a filename or RAW JSON");
}

var fileOpsConfiguration = await mediator.Send(new ParseCommand
{
    FileName = applicationConfiguration.FileName,
    Json = applicationConfiguration.Json
}, cancellationToken);

var processedResult = await mediator.Send(new ProcessCommand { 
    Configuration = fileOpsConfiguration }, cancellationToken);

Console.WriteLine(processedResult);
----END OF FILE----
----net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs----
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

----END OF FILE----
----net8.0/FileOps.AssemblyInfo.cs----
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("FileOps")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+e5283a88c0d3cdd2e9176613713bc5c8d7b48570")]
[assembly: System.Reflection.AssemblyProductAttribute("FileOps")]
[assembly: System.Reflection.AssemblyTitleAttribute("FileOps")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


----END OF FILE----
----net8.0/FileOps.GlobalUsings.g.cs----
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

----END OF FILE----
----FileOps.Core/ServiceRegistration.cs----
using FileOps.Core.Features.Process;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.FileProviders;
using Scrutor;
using Shared;
using System.Reflection;

namespace FileOps.Core;

public static class ServiceRegistration
{
    internal static IServiceCollection AddInternalServices(
        this IServiceCollection services, params Assembly[] assemblies)
    {
        return services
            .AddSingleton(TimeProvider.System)
            .AddSingleton<IClockProvider, SystemClockProvider>()
            .AddSingleton<IDirectoryOperation, FileSystemDirectoryOperation>()
            .AddSingleton<IFileOperation, FileSystemOperation>()
            .AddSingleton<IFileProvider, FileSystemProvider>()
            .AddSingleton<IOperationExecutorMapper, OperationExecutorMapper>()
            .Scan(s => s.FromAssemblies(assemblies).AddClasses(a => a.WithAttribute<ServiceDescriptorAttribute>())
            .AsImplementedInterfaces());
    }

    public static IServiceCollection RegisterServices(this IServiceCollection services, 
        IEnumerable<Assembly>? assemblies = null,
        MediatRServiceConfiguration? mediatRServiceConfiguration = null)
    {
        var thisAssembly = typeof(ServiceRegistration).Assembly;
        if (assemblies == null)
        {
            assemblies = new[] {
                thisAssembly
            };
        }
        else
        {
            assemblies = assemblies.Append(thisAssembly);
        }

        if(mediatRServiceConfiguration != null)
        {
            mediatRServiceConfiguration
                .RegisterServicesFromAssembly(thisAssembly);
        }
        else
        {
            services
                .AddInternalServices(assemblies.ToArray())
                .AddMediatR(c => c.RegisterServicesFromAssemblies(
                    assemblies.ToArray()));
        }

        return services;
    }
}

----END OF FILE----
----Parse/DirectoryResolution.cs----
namespace FileOps.Core;

public enum DirectoryResolution
{
    CreateDirectories,
    UseExisting
}

----END OF FILE----
----Parse/FailureAction.cs----
namespace FileOps.Core;

[Flags]
public enum FailureAction
{
    AbortOnError,
    LogError,
    SkipFile
}

----END OF FILE----
----Parse/Parse.cs----
using MediatR;
using Microsoft.Extensions.FileProviders;
using System.Text.Json;

namespace FileOps.Core.Features.Parse;

internal class Parse(IFileProvider fileProvider) : IRequestHandler<ParseCommand, IFileOpsConfiguration?>
{
    public async Task<IFileOpsConfiguration?> Handle(ParseCommand request, CancellationToken cancellationToken)
    {
        var json = request.Json;
        if (string.IsNullOrWhiteSpace(json) && !string.IsNullOrWhiteSpace(request.FileName))
        {
            var file = fileProvider.GetFileInfo(request.FileName);
            if (!file.Exists)
            {
                throw new FileNotFoundException($"{request.FileName}");
            }

            using var streamReader = new StreamReader(file.CreateReadStream());
            json = await streamReader.ReadToEndAsync(cancellationToken);
        }

        if (string.IsNullOrWhiteSpace(json))
        {
            throw new NullReferenceException("Unable to parse JSON from request or requested file");
        }
        using var jsonDocument = JsonDocument.Parse(json);

        return JsonFileOpsConfiguration.Parse(jsonDocument);
    }
}

----END OF FILE----
----Parse/ParseCommand.cs----
using MediatR;

namespace FileOps.Core.Features.Parse;

public record ParseCommand : IRequest<IFileOpsConfiguration?>
{
    public string? FileName { get; set; }
    public string? Json { get; set; }
}

----END OF FILE----
----Parse/PathResolution.cs----
namespace FileOps.Core;

public enum PathResolution
{
    Absolute,
    Relative
}

----END OF FILE----
----Configuration/CopyOperationConfiguration.cs----
namespace FileOps.Core;

internal record CopyOperationConfiguration : OperationConfigurationBase, IFileTransferOperationConfiguration
{
    public CopyOperationConfiguration() : base(Operation.Copy)
    {

    }

    public string? To { get; set; }
    public string? RootPath { get; set; }
    public IEnumerable<string>? Files { get; set; }
}

----END OF FILE----
----Configuration/FileOpsConfiguration.cs----
namespace FileOps.Core;

public interface IFileOpsConfiguration
{
    string? RootPath { get; set; }
    IEnumerable<IFileTransferOperationConfiguration>? Move { get; set; }
    IEnumerable<IFileTransferOperationConfiguration>? Copy { get; set; }
    IEnumerable<IValidationOperationConfiguration>? Verify { get; set; }
}

internal record FileOpsConfiguration : IFileOpsConfiguration
{
    public static implicit operator FileOpsConfiguration?(JsonFileOpsConfiguration? configuration)
    {
        if (configuration == null)
        {
            return null;
        }

        return new FileOpsConfiguration
        {
            RootPath = configuration.RootPath,
            Move = configuration.Move,
            Copy = configuration.Copy,
            Verify = configuration.Verify,
        };

    }

    public string? RootPath { get; set; }
    public IEnumerable<IFileTransferOperationConfiguration>? Move { get; set; }
    public IEnumerable<IFileTransferOperationConfiguration>? Copy { get; set; }
    public IEnumerable<IValidationOperationConfiguration>? Verify { get; set; }
}

----END OF FILE----
----Configuration/IFileOperationConfiguration.cs----
namespace FileOps.Core;

public interface IFileOperationConfiguration : IOperationConfiguration
{
    string? RootPath { get; }
    IEnumerable<string>? Files { get; }
}

----END OF FILE----
----Configuration/IFileTransferOperationConfiguration.cs----
namespace FileOps.Core;

public interface IFileTransferOperationConfiguration : IFileOperationConfiguration
{
    string? To { get; }
}

----END OF FILE----
----Configuration/IOperationConfiguration.cs----
namespace FileOps.Core;

public enum  Operation
{
    Copy,
    Move,
    Verify
}

public interface IOperationConfiguration
{
    Operation Operation { get; }
    DirectoryResolution DirectoryResolution { get; }
    string? Description { get; }
    bool Enabled { get; }
    PathResolution PathResolution { get; }
    FailureAction FailureAction { get; }
}

----END OF FILE----
----Configuration/IValidationOperationConfiguration.cs----
namespace FileOps.Core;

public interface IValidationOperationConfiguration : IFileOperationConfiguration
{
    bool Exists { get; }
}

----END OF FILE----
----Configuration/JsonFileOpsConfiguration.cs----
using System.Text.Json;
using System.Text.Json.Serialization;

namespace FileOps.Core;

internal record JsonFileOpsConfiguration : IFileOpsConfiguration
{
    public static JsonSerializerOptions GetDefault(JsonSerializerOptions? options = null)
    {
        var opts = options ?? new JsonSerializerOptions();

        opts.PropertyNameCaseInsensitive = true;
        opts.Converters.Add(new JsonStringEnumConverter());

        return opts;
    }

    public static FileOpsConfiguration? Parse(JsonDocument json, 
        JsonSerializerOptions? options = null)
    {
        options = GetDefault(options);

        return json.Deserialize<JsonFileOpsConfiguration>(options);
    }

    public string? RootPath { get; set; }
    public IEnumerable<MoveOperationConfiguration>? Move { get; set; }
    public IEnumerable<CopyOperationConfiguration>? Copy { get; set; }
    public IEnumerable<VerifyOperationConfiguration>? Verify { get; set; }

    IEnumerable<IFileTransferOperationConfiguration>? IFileOpsConfiguration.Copy 
    { 
        get => Copy;
        set => Copy = (IEnumerable<CopyOperationConfiguration>?)value; 
    }
    IEnumerable<IFileTransferOperationConfiguration>? IFileOpsConfiguration.Move
    {
        get => Move;
        set => Move = (IEnumerable<MoveOperationConfiguration>?)value;
    }
    IEnumerable<IValidationOperationConfiguration>? IFileOpsConfiguration.Verify
    {
        get => Verify;
        set => Verify = (IEnumerable<VerifyOperationConfiguration>?)value;
    }
}

----END OF FILE----
----Configuration/MoveOperationConfiguration.cs----
namespace FileOps.Core;

internal record MoveOperationConfiguration : OperationConfigurationBase, IFileTransferOperationConfiguration
{
    public MoveOperationConfiguration() : base(Operation.Move)
    {

    }

    public string? To { get; set; }
    public string? RootPath { get; set; }
    public IEnumerable<string>? Files { get; set; }
}

----END OF FILE----
----Configuration/OperationConfigurationBase.cs----
namespace FileOps.Core;

internal abstract record OperationConfigurationBase : IOperationConfiguration
{
    public OperationConfigurationBase(Operation operation)
    {
        Operation = operation;
    }

    public DirectoryResolution DirectoryResolution { get; set; }
    public string? Description { get; set; }
    public bool Enabled { get; set; }
    public PathResolution PathResolution { get; set; }
    public FailureAction FailureAction { get; set; }
    public Operation Operation { get; set; }
}
----END OF FILE----
----Configuration/VerifyOperationConfiguration.cs----
namespace FileOps.Core;

internal record VerifyOperationConfiguration : OperationConfigurationBase, IValidationOperationConfiguration
{
    public VerifyOperationConfiguration()
        : base(Operation.Verify)
    {

    }
    public bool Exists { get; set; }
    public string? RootPath { get; set; }
    public IEnumerable<string>? Files { get; set; }
}
----END OF FILE----
----Process/IOperationExecutorMapper.cs----
using FileOps.Core.Operations;

namespace FileOps.Core.Features.Process;

internal interface IOperationExecutorMapper
{
    IEnumerable<OperationExecutorMapping> GetMappings(IFileOpsConfiguration configuration);
}


internal class OperationExecutorMapper(IEnumerable<IOperationExecutor> operationExecutors) : IOperationExecutorMapper
{
    public IEnumerable<OperationExecutorMapping> GetMappings(IFileOpsConfiguration configuration)
    {
        var executorMappingList = new List<OperationExecutorMapping>();
        foreach(var executor in operationExecutors)
        {
            var allConfiguration = Array.Empty<IOperationConfiguration>().AsEnumerable();

            if(configuration.Copy != null)
            {
                allConfiguration = allConfiguration.Union(configuration.Copy);
            }
            if (configuration.Move != null)
            {
                allConfiguration = allConfiguration.Union(configuration.Move);
            }
            if (configuration.Verify != null)
            {
                allConfiguration = allConfiguration.Union(configuration.Verify);
            }
            var applicableConfigurations = allConfiguration.Where(executor.CanExecute);
            if (applicableConfigurations.Any())
            {
                executorMappingList.Add(new OperationExecutorMapping(configuration)
                {
                    OperationConfiguration = applicableConfigurations,
                    OperationExecutor = executor
                });
            }
        }

        return executorMappingList;
    }
}

----END OF FILE----
----Process/OperationExecutorMapping.cs----
using FileOps.Core.Operations;

namespace FileOps.Core.Features.Process;

internal record OperationExecutorMapping
{
    public OperationExecutorMapping(IFileOpsConfiguration configuration)
    {
        Configuration = configuration;
        OperationConfiguration = Array.Empty<IOperationConfiguration>();
    }
    public IFileOpsConfiguration Configuration { get; }
    public IOperationExecutor? OperationExecutor { get; init; }
    public IEnumerable<IOperationConfiguration> OperationConfiguration { get; init; }
    public async Task ExecuteAll(OperationLedger operationLedger, 
        CancellationToken cancellationToken)
    {
        foreach(var operationConfiguration in OperationConfiguration)
        {
            if (OperationExecutor != null)
            {
                OperationExecutor.Configuration = Configuration;
                OperationExecutor.LedgerEntries = operationLedger;
                await OperationExecutor.Execute(operationConfiguration, cancellationToken);
            }
        }
    }
}

----END OF FILE----
----Process/Process.cs----
using MediatR;

namespace FileOps.Core.Features.Process;

internal class Process(IOperationExecutorMapper operationProcessor) : IRequestHandler<ProcessCommand, OperationLedger>
{

    public async Task<OperationLedger> Handle(ProcessCommand request, CancellationToken cancellationToken)
    {
        var operationLedger = new OperationLedger();
        if(request.Configuration == null)
        {
            throw new NullReferenceException("Configuration not specified");
        }

        var operators = operationProcessor
            .GetMappings(request.Configuration);
        
        foreach(var @operator in operators)
        {
            await @operator.ExecuteAll(operationLedger, cancellationToken);
        }

        return operationLedger;
    }
}

----END OF FILE----
----Process/ProcessCommand.cs----
using MediatR;

namespace FileOps.Core.Features.Process;

public record ProcessCommand : IRequest<OperationLedger>
{
    public IFileOpsConfiguration? Configuration { get; set; }
}

----END OF FILE----
----Operations/CopyOperationExecutor.cs----
using Microsoft.Extensions.FileProviders;
using Scrutor;
using Shared;

namespace FileOps.Core.Operations;

[ServiceDescriptor]
internal class CopyOperationExecutor(IFileProvider fileProvider, IDirectoryOperation directoryOperation, IFileOperation fileOperation,
    IClockProvider clockProvider) : FileOperationExecutorBase<CopyOperationConfiguration>( 
    fileProvider, directoryOperation,
    Operation.Copy, clockProvider)
{
    protected override async ValueTask<bool> ProcessFile(IFileTransferOperationConfiguration operationConfiguration, 
        string destination, IFileInfo file, CancellationToken cancellationToken)
    {
        if(file.PhysicalPath == null)
        {
            throw new NullReferenceException("File not specified");
        }

        if (file.Exists)
        {
            var copiedFileInfo = await fileOperation.CopyFileAsync(file, Path.Combine(destination, file.Name), cancellationToken, true);

            LedgerEntries?.Add(new OperationLedgerEntry(ClockProvider)
            {
                Configuration = operationConfiguration,
                Result = copiedFileInfo,
                Succeeded = copiedFileInfo.Exists
            });
            return true;
        }

        LedgerEntries?.Add(new OperationLedgerEntry(ClockProvider)
        {
            Configuration = operationConfiguration,
            Exception = new NullReferenceException($"File '{file.PhysicalPath}' not found")
        });

        return false;
    }
}

----END OF FILE----
----Operations/FileOperationExecutorBase.cs----
using Microsoft.Extensions.FileProviders;
using Shared;

namespace FileOps.Core.Operations;

internal abstract class FileOperationExecutorBase<TFileOperationConfiguration>(IFileProvider fileProvider, 
    IDirectoryOperation directoryOperation, Operation operation, IClockProvider clockProvider) : OperationExecutorBase<TFileOperationConfiguration>(operation, clockProvider)
    where TFileOperationConfiguration : IFileTransferOperationConfiguration
{
    protected IFileProvider FileProvider => fileProvider;
    public override async Task Execute(TFileOperationConfiguration configuration, CancellationToken cancellationToken)
    {
        try
        {
            if (configuration.PathResolution == PathResolution.Relative
                && string.IsNullOrWhiteSpace(configuration.RootPath))
            {
                throw new NullReferenceException("Root path must be specified");
            }

            if (string.IsNullOrWhiteSpace(configuration.To))
            {
                throw new NullReferenceException($"Destination {nameof(configuration.To)} not specified");
            }

            var toPath = ResolvePath(configuration, configuration.RootPath!, configuration.To);

            if (configuration.DirectoryResolution == DirectoryResolution.CreateDirectories
                && !await directoryOperation.ExistsAsync(toPath, cancellationToken))
            {
                await directoryOperation.CreateDirectoryAsync(toPath, cancellationToken);
            }

            if (configuration.Files == null)
            {
                throw new NullReferenceException("No files to process");
            }

            foreach (var file in configuration.Files)
            {
                var filePath = ResolvePath(configuration, configuration.RootPath!, file);

                var fileInfo = fileProvider.GetFileInfo(filePath);
                await ProcessFile(configuration, toPath, fileInfo, cancellationToken);
            }
        }
        catch (IOException exception)
        {
            if (!await HandleException(configuration, exception))
            {
                throw;
            }
        }
        catch (NullReferenceException exception)
        {
            if (!await HandleException(configuration, exception))
            {
                throw;
            }
        }
    }

    protected abstract ValueTask<bool> ProcessFile(
        IFileTransferOperationConfiguration operationConfiguration, string destination, 
        IFileInfo file, CancellationToken cancellationToken);
}

----END OF FILE----
----Operations/FileSystemDirectoryContents.cs----
using Microsoft.Extensions.FileProviders;
using Microsoft.Extensions.FileProviders.Physical;
using System.Collections;

namespace FileOps.Core;

internal record FileSystemDirectoryContents(DirectoryInfo Directory) : IDirectoryContents
{
    private IEnumerable<IFileInfo>? files;
    public bool Exists { get => Directory.Exists; }

    private IEnumerable<IFileInfo> Files
    {
        get
        {
            if(files != null)
            {
                return files;
            }

            var fileList = new List<IFileInfo>();

            fileList.AddRange(Directory
                .EnumerateDirectories()
                .Select(s => (IFileInfo)new PhysicalDirectoryInfo(s)));

            fileList.AddRange(Directory
                .EnumerateFiles()
                .Select(s => (IFileInfo)new PhysicalFileInfo(s)));

            return files = fileList.ToArray();
        }
    }

    public IEnumerator<IFileInfo> GetEnumerator()
    {
        return Files.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return Files.GetEnumerator();
    }
}

----END OF FILE----
----Operations/FileSystemProvider.cs----
using Microsoft.Extensions.FileProviders;
using Microsoft.Extensions.FileProviders.Physical;
using Microsoft.Extensions.Primitives;

namespace FileOps.Core;

internal class FileSystemProvider : IFileProvider
{
    public IDirectoryContents GetDirectoryContents(string subpath)
    {
        return new FileSystemDirectoryContents(new DirectoryInfo(subpath));
    }

    public IFileInfo GetFileInfo(string subpath)
    {
        return new PhysicalFileInfo(new FileInfo(subpath));
    }

    public IChangeToken Watch(string filter)
    {
        throw new NotImplementedException();
    }
}
----END OF FILE----
----Operations/IDirectoryOperation.cs----
using Microsoft.Extensions.FileProviders;
using Microsoft.Extensions.FileProviders.Physical;

namespace FileOps.Core;

public interface IDirectoryOperation
{
    Task<bool> ExistsAsync(string path, CancellationToken cancellationToken);
    Task<IFileInfo> CreateDirectoryAsync(string path, CancellationToken cancellationToken);
}

public class FileSystemDirectoryOperation : IDirectoryOperation
{
    public Task<IFileInfo> CreateDirectoryAsync(string path, CancellationToken cancellationToken)
    {
        Directory.CreateDirectory(path);
        return Task.FromResult<IFileInfo>(new PhysicalDirectoryInfo(new DirectoryInfo(path)));
    }

    public Task<bool> ExistsAsync(string path, CancellationToken cancellationToken)
    {
        return Task.FromResult(Directory.Exists(path));
    }
}
----END OF FILE----
----Operations/IFileOperation.cs----
using Microsoft.Extensions.FileProviders;
using Microsoft.Extensions.FileProviders.Physical;

namespace FileOps.Core;

public interface IFileOperation
{
    ValueTask<bool> ExistsAsync(string path, CancellationToken cancellationToken);
    Task<IFileInfo> CopyFileAsync(IFileInfo fileInfo, string newFilePath, CancellationToken cancellationToken, bool overwrite = false);
    Task<IFileInfo> MoveFileAsync(IFileInfo fileInfo, string newFilePath, CancellationToken cancellationToken, bool overwrite = false);
}

public class FileSystemOperation : IFileOperation
{
    public Task<IFileInfo> CopyFileAsync(IFileInfo fileInfo, string newFilePath, CancellationToken cancellationToken, bool overwrite = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(fileInfo.PhysicalPath);
        if (fileInfo.Exists)
        {
            File.Copy(fileInfo.PhysicalPath, newFilePath, overwrite);
            return Task.FromResult<IFileInfo>(
            new PhysicalFileInfo(new FileInfo(newFilePath)));
        }

        return Task.FromResult<IFileInfo>(
            new PhysicalFileInfo(new FileInfo(newFilePath)));
    }

    public ValueTask<bool> ExistsAsync(string path, CancellationToken cancellationToken)
    {
        return ValueTask.FromResult(File.Exists(path));
    }

    public Task<IFileInfo> MoveFileAsync(IFileInfo fileInfo, string newFilePath, CancellationToken cancellationToken, bool overwrite = false)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(fileInfo.PhysicalPath);
        if (fileInfo.Exists)
        {
            File.Move(fileInfo.PhysicalPath, newFilePath, overwrite);
            return Task.FromResult<IFileInfo>(
            new PhysicalFileInfo(new FileInfo(newFilePath)));
        }

        return Task.FromResult<IFileInfo>(
            new PhysicalFileInfo(new FileInfo(newFilePath)));
    }
}
----END OF FILE----
----Operations/IOperationExecutor.cs----
namespace FileOps.Core.Operations;

internal interface IOperationExecutor
{
    IFileOpsConfiguration? Configuration { get; set; }
    OperationLedger? LedgerEntries { get; set; }
    Operation Operation { get; }
    bool CanExecute(IOperationConfiguration configuration);
    Task Execute(IOperationConfiguration configuration, CancellationToken cancellationToken);
}
----END OF FILE----
----Operations/MoveOperationExecutor.cs----
using Microsoft.Extensions.FileProviders;
using Scrutor;
using Shared;

namespace FileOps.Core.Operations;

[ServiceDescriptor]
internal class MoveOperationExecutor(IFileProvider fileProvider, IDirectoryOperation directoryOperation, IFileOperation fileOperation,
    IClockProvider clockProvider) : FileOperationExecutorBase<MoveOperationConfiguration>(fileProvider,
    directoryOperation, Operation.Move, clockProvider)
{
    protected override async ValueTask<bool> ProcessFile(IFileTransferOperationConfiguration operationConfiguration, string destination, 
        IFileInfo file, CancellationToken cancellationToken)
    {
        if (file.PhysicalPath == null)
        {
            throw new NullReferenceException("File not specified");
        }

        if (file.Exists)
        {
            var movedFileInfo = await fileOperation
                .MoveFileAsync(file, Path.Combine(destination, file.Name), 
                cancellationToken, true);

            LedgerEntries?.Add(new OperationLedgerEntry(ClockProvider)
            {
                Configuration = operationConfiguration,
                Result = movedFileInfo,
                Succeeded = movedFileInfo.Exists
            });
            return true;
        }

        LedgerEntries?.Add(new OperationLedgerEntry(ClockProvider)
        {
            Configuration = operationConfiguration,
            Exception = new NullReferenceException($"File '{file.PhysicalPath}' not found")
        });

        return false;
    }
}

----END OF FILE----
----Operations/OperationExecutorBase.cs----
using Shared;

namespace FileOps.Core.Operations;

internal abstract class OperationExecutorBase(Operation operation,
    IClockProvider clockProvider) : IOperationExecutor
{
    protected IClockProvider ClockProvider => clockProvider;
    /// <summary>
    /// 
    /// </summary>
    /// <param name="configuration"></param>
    /// <param name="exception"></param>
    /// <param name="succeeded"></param>
    /// <returns>A task that determines where the exception was handled</returns>
    protected ValueTask<bool> HandleException(IOperationConfiguration configuration, 
        Exception exception, bool succeeded = false)
    {
        LedgerEntries?.Add(new OperationLedgerEntry(clockProvider)
        {
            Configuration = configuration,
            Exception = exception,
            Succeeded = succeeded
        });

        if (configuration.FailureAction == FailureAction.AbortOnError)
        {
            return ValueTask.FromResult(false);
        }

        return ValueTask.FromResult(true);
    }

    public IFileOpsConfiguration? Configuration { get; set; }
    public OperationLedger? LedgerEntries { get; set; }
    public Operation Operation { get; } = operation;
    
    public virtual bool CanExecute(IOperationConfiguration configuration)
    {
        return configuration.Enabled 
            && configuration.Operation == Operation;
    }

    public abstract Task Execute(IOperationConfiguration configuration, 
        CancellationToken cancellationToken);
}
----END OF FILE----
----Operations/OperationExecutorGenericBase.cs----
using Shared;
using System.Reflection.Metadata.Ecma335;

namespace FileOps.Core.Operations;

internal abstract class OperationExecutorBase<TOperationConfiguration>(Operation operation, IClockProvider clockProvider)
    : OperationExecutorBase(operation, clockProvider)
    where TOperationConfiguration : IOperationConfiguration
{
    protected string ResolvePath(TOperationConfiguration configuration, 
        string rootPath, string path)
    {
        return configuration.PathResolution == PathResolution.Absolute
            ? path
            : string.IsNullOrWhiteSpace(Configuration?.RootPath)
                ? Path.Combine(rootPath, path)
                : Path.Combine(Configuration.RootPath, rootPath, path);
    }

    public override bool CanExecute(IOperationConfiguration configuration)
    {
        return configuration is TOperationConfiguration operationConfiguration
            && base.CanExecute(configuration) 
            && this.CanExecute(operationConfiguration);
    }

    public override Task Execute(IOperationConfiguration configuration, 
        CancellationToken cancellationToken)
    {
        if (configuration is TOperationConfiguration operationConfiguration)
        {
            return Execute(operationConfiguration, cancellationToken);
        }

        return Task.CompletedTask;
    }

    public virtual bool CanExecute(TOperationConfiguration configuration)
    {
        return true;
    }

    public abstract Task Execute(TOperationConfiguration configuration,
        CancellationToken cancellationToken);
}
----END OF FILE----
----Operations/OperationLedger.cs----
using System.Collections;
using System.Text;

namespace FileOps.Core;

public class OperationLedger : IEnumerable<OperationLedgerEntry>
{
    private readonly IList<OperationLedgerEntry> ledgerEntries;
    
    public OperationLedger()
    {
        ledgerEntries = new List<OperationLedgerEntry>();
    }

    public void Add(OperationLedgerEntry entry)
    {
        ledgerEntries.Add(entry);
    }

    public IEnumerator<OperationLedgerEntry> GetEnumerator()
    {
        return ledgerEntries.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ledgerEntries.GetEnumerator();
    }

    public override string ToString()
    {
        var stringBuilder = new StringBuilder();
        foreach(var entry in ledgerEntries) 
        {
            stringBuilder.AppendLine(entry.ToString());
        }
        return stringBuilder.ToString();
    }
}
----END OF FILE----
----Operations/OperationLedgerEntry.cs----
using Shared;

namespace FileOps.Core;

public record OperationLedgerEntry(IClockProvider ClockProvider)
{
    private DateTimeOffset? loggedUtcDate;
    public DateTimeOffset LoggedUtcDate { get => loggedUtcDate 
            ?? (loggedUtcDate = ClockProvider.UtcTime ?? throw new NullReferenceException()).Value; }
    public IOperationConfiguration? Configuration { get; init; }
    public object? Result { get; init; }
    public bool Succeeded { get; init; }
    public Exception? Exception { get; init; }
}

----END OF FILE----
----Operations/VerifyOperationExecutor.cs----
using Scrutor;
using Shared;
using System.Linq;

namespace FileOps.Core.Operations;

[ServiceDescriptor]
internal class VerifyOperationExecutor(IDirectoryOperation directoryOperation,
    IFileOperation fileOperation, IClockProvider clockProvider) : OperationExecutorBase<VerifyOperationConfiguration>(Operation.Verify, clockProvider)
{
    public override async Task Execute(VerifyOperationConfiguration configuration, CancellationToken cancellationToken)
    {
        try
        {
            if (configuration.PathResolution == PathResolution.Relative 
                && (string.IsNullOrWhiteSpace(configuration.RootPath) 
                || !await directoryOperation.ExistsAsync(configuration.RootPath, cancellationToken)))
            {
                throw new DirectoryNotFoundException($"Root path not specified or found: {configuration.RootPath} when path resolution is relative");
            }

            if (configuration.Files == null)
            {
                throw new NullReferenceException("No files to process");
            }

            var files = configuration.Files!.ToAsyncEnumerable()
                .WhereAwaitWithCancellation(async(f,c) => !await fileOperation
                    .ExistsAsync(ResolvePath(configuration, configuration.RootPath!, f), c));

            if (await files.AnyAsync(cancellationToken))
            {
                var filesArray = await files.ToArrayAsync(cancellationToken);
                throw new FileNotFoundException($"The following files could not be found: ${string.Join(',', filesArray)}");
            }
            var exists = true;
            
            LedgerEntries?.Add(new OperationLedgerEntry(ClockProvider)
            {
                Configuration = configuration,
                Result = exists == configuration.Exists,
                Succeeded = exists == configuration.Exists
            });

        }
        catch (FileNotFoundException exception)
        {
            var exists = false;
            if (!await HandleException(configuration, exception, exists == configuration.Exists))
                throw;
        }
        catch(IOException exception)
        {
            if (!await HandleException(configuration, exception))
                throw;
        }
        catch(NullReferenceException exception)
        {
            if (!await HandleException(configuration, exception))
                throw;
        }
    }
}

----END OF FILE----
----net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs----
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

----END OF FILE----
----net8.0/FileOps.Core.AssemblyInfo.cs----
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("FileOps.Core")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+eda615486d213893c049db406ba079cbca43d292")]
[assembly: System.Reflection.AssemblyProductAttribute("FileOps.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("FileOps.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


----END OF FILE----
----net8.0/FileOps.Core.GlobalUsings.g.cs----
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

----END OF FILE----
----Properties/AssemblyInfo.cs----
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("FileOps.Tests")]
----END OF FILE----
----FileOps.Tests/CopyOperationExecutorTests.cs----
using FileOps.Core;
using FileOps.Core.Operations;
using Microsoft.Extensions.FileProviders;
using Moq;

namespace FileOps.Tests;

[TestFixture]
public class CopyOperationExecutorTests
{
    [Test]
    public async Task Execute_does_its_task()
    {
        var fileProviderMock = new Mock<IFileProvider>();
        var directoryOperationMock = new Mock<IDirectoryOperation>();
        var fileOperationMock = new Mock<IFileOperation>();
        var ledger = new OperationLedger();
        var executor = new CopyOperationExecutor(fileProviderMock.Object, directoryOperationMock.Object, fileOperationMock.Object)
        {
            LedgerEntries = ledger
        };
        await executor.Execute(new CopyOperationConfiguration
        {
            FailureAction = FailureAction.SkipFile
        }, CancellationToken.None);
    }
}

----END OF FILE----
----FileOps.Tests/GlobalUsings.cs----
global using NUnit.Framework;
----END OF FILE----
----FileOps.Tests/JsonFileOpsConfigurationTests.cs----
using FileOps.Core;
using System.Text.Json;

namespace FileOps.Tests;

public class JsonFileOpsConfigurationTests
{
    [SetUp]
    public void Setup()
    {
    }

    [Test]
    public void JsonFileOpsConfiguration_Parse()
    {
        const string json = @"{
  ""rootPath"": ""C:\\Source\\Repos"",
  ""move"": [
    {
      ""directoryResolution"": ""CreateDirectories"",
      ""description"": ""Moves the generated LIC file compiled by the build agent"",
      ""enabled"": true,
      ""to"": ""output"",
      ""pathResolution"": ""relative"",
      ""rootPath"": ""JsonExtractor.Web"",
      ""failureAction"": ""AbortOnError"",
      ""files"": [
        ""cypress.lic""
      ]
    }
  ],
  ""copy"": [
    {
      ""directoryResolution"": ""CreateDirectories"",
      ""description"": ""Copy content files to the web root"",
      ""enabled"": true,
      ""to"": ""wwwroot"",
      ""pathResolution"": ""relative"",
      ""rootPath"": ""JsonExtractor.Web"",
      ""failureAction"": ""skipFile"",
      ""files"": [
        ""AuthorInfo.json"",
        ""dark-theme.append.txt""
      ]
    }
  ],
  ""verify"": [
    {
      ""exists"": true,
      ""rootPath"": ""JsonExtractor.Web"",
      ""files"": [
        ""AuthorInfo.json"",
        ""dark-theme.append.txt"",
        ""cypress.lic""
      ]
    }
  ]
}";
        using var jsonDocument = JsonDocument.Parse(json);
        FileOpsConfiguration? configuration = JsonFileOpsConfiguration.Parse(jsonDocument);
        Assert.That(configuration, Is.Not.Null);
        Assert.That(configuration.RootPath, Is.EqualTo("C:\\Source\\Repos"));
    }
}
----END OF FILE----
----net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs----
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

----END OF FILE----
----net8.0/FileOps.Tests.AssemblyInfo.cs----
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("FileOps.Tests")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+e53e72770f057336a7080000ccee26aaa4855f29")]
[assembly: System.Reflection.AssemblyProductAttribute("FileOps.Tests")]
[assembly: System.Reflection.AssemblyTitleAttribute("FileOps.Tests")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.


----END OF FILE----
----net8.0/FileOps.Tests.GlobalUsings.g.cs----
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

----END OF FILE----
----FileOps/FileOps.csproj----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <OutputType>Exe</OutputType>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\FileOps.Core\FileOps.Core.csproj" />
  </ItemGroup>
  <ItemGroup>
    <Reference Include="Shared">
      <HintPath>..\..\..\Shared\Shared.Console\bin\Debug\net8.0\Shared.dll</HintPath>
    </Reference>
    <Reference Include="Shared.Console">
      <HintPath>..\..\..\Shared\Shared.Console\bin\Debug\net8.0\Shared.Console.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <None Update="Include.json">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </None>
  </ItemGroup>
</Project>

----END OF FILE----
----FileOps.Core/FileOps.Core.csproj----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
<ItemGroup>
  <PackageReference Include="MediatR" Version="12.2.0" />
  <PackageReference Include="Microsoft.Extensions.FileProviders.Abstractions" Version="8.0.0" />
  <PackageReference Include="Microsoft.Extensions.FileProviders.Physical" Version="8.0.0" />
  <PackageReference Include="Scrutor" Version="4.2.2" />
  <PackageReference Include="System.Linq.Async" Version="6.0.1" />
</ItemGroup>
<ItemGroup>
  <Reference Include="Shared">
    <HintPath>..\..\..\Shared\bin\Debug\net8.0\Shared.dll</HintPath>
  </Reference>
</ItemGroup>
</Project>

----END OF FILE----
----FileOps.Tests/FileOps.Tests.csproj----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <IsPackable>false</IsPackable>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.6.0" />
    <PackageReference Include="Moq" Version="4.20.70" />
    <PackageReference Include="NUnit" Version="3.13.3" />
    <PackageReference Include="NUnit3TestAdapter" Version="4.2.1" />
    <PackageReference Include="NUnit.Analyzers" Version="3.6.1" />
    <PackageReference Include="coverlet.collector" Version="6.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\src\FileOps.Core\FileOps.Core.csproj" />
  </ItemGroup>

</Project>

----END OF FILE----

